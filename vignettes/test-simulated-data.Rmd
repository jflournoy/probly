---
title: "Test Simulated Data"
author: "John Flournoy"
date: "`r Sys.Date()`"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: "`r system.file('bib', 'dissertation.bib', package = 'probly')`"
csl: "`r system.file('bib', 'apa-old-doi-prefix.csl', package = 'probly')`"
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo=F,message=F,warning=F,error=F
)

knitr::read_chunk(system.file('r_aux', 'simulate_data_from_splt.R', package = 'probly'))
knitr::read_chunk(system.file('r_aux', 'estimate_rl_from_sim.R', package = 'probly'))
data_dir <- '/data/jflournoy/split/probly'
```

**Aim 1a:** Does framing reinforcement learning with (mate-seeking and status) motivational contexts sensitize the learner and potentiate learning?

My approach to answering this question is to model how learning occurs in each of the three motive contexts and examine differences in how learning occurs.

# Task Descriptions

**TASK DESCRIPTION HERE**

# A model for reinforcement learning

In the context of this task, where the relation between the optimal response and the stimulus is constant, a simple model of the degree of learning could rely on a simple proportion of optimal responses $P_{ok}$ for each condition $k$.
The test of the hypothesis of the effect of framing would then be the difference between conditions in $P_o$. 
This simple model sacrifice precision for simplicity, and so I will be modeling the data using a reinforcement learning model with several parameters that can account for deviations from a strict Rescorla-Wagner (RW) process.
This increases the number of possible comparisons I am able to make between conditions, which may generate useful information about how motive-domain framing affects the learning process (as modeled, of course), but which also increases the complexity of patterns between conditions and parameters that must be interpreted.
It will be helpful to keep in mind that the framing can only be said to potentiate learning if, regardless of its affect on any model parameters, it does not result in higher proportions of optimal responding.

In this section, I simulate data as expected under the Rescorla-Wagner model implemented by @ahn2017 in their go-no-go model 2. 
Their original model handles binary decisions (button-press or no button-press) in response to four different cues. 
However, the form of the learning algorithm is generalizable to other binary choices in response to cues. 
In the case of the Social Probabilistic Learning Task (SPLT), participants are presented with a face (the cue), and must decide to press the left key or the right key. 
They are rewarded probabilistically such that for each cue, one or the other of the response options has an 80% chance of providing reinforcement. 
The go-no-go models used by @ahn2017 were derived from work by @guitart-masip2012. 
Their most flexible reinforcement learning model generates the probability of an action for each trial via N parameters: the learning rate, $\epsilon$, the effective size of reinforcement, $\rho$, a static bias parameter, $b$, an irreducible noise parameter, $\xi$, and a Pavlovian learning parameter, $\pi$.
In the SPLT, trial feedback does not vary by valence (responses result in reward, or no reward, but never punishment), so I use the model that does not include this Pavlovian component. 

# Reinforcement learning model for the SPLT

The model for an individual $j$'s probability of pressing the right arrow key on trial $t$ given that stimulus $s_{t}$ is presented, $P(a_{\rightarrow t} | s_{t})_{t}$, is determined by a logistic transformation of the action weight for pressing the right arrow key minus the action weight for pressing the left arrow key. 
This probability is then adjusted by a noise parameter, $0 \leq\xi_{jk}\leq1$ for each participant $j$ in condition $k$.
The noise parameter modulates the degree to which responses are non-systematic. 
When $\xi$ is 1, $P_{it} = .5$, and because each individual has a unique noise parameter for each condition, I am able to account for participants who do not learn during the task, or in a particular condition.
The full equation is:

$$
P(a_{\rightarrow t} | s_{t})_{t} = 
\text{logit}^{-1}\big(W(a_{\rightarrow t}| s_{t}) - W(a_{\leftarrow t}| s_{t})\big)\cdot(1-\xi_{jk}) + \small\frac{\xi_{jk}}{2}.
$$

The action weight is determined by a Rescorla-Wagner (RW) updating equation and individual $j$'s bias parameter, $b_{jk}$, for that condition (which encodes a systematic preference for choosing the left or right response option).
In each condition, the same two words are displayed in the same position, so $b$ encodes a learning-independent preference for one particular word or position.
The equation for the action weight for each action on a particular trial is:

$$
W_{t}(a,s) = \left\{
                \begin{array}{ll}
                  Q_{t}(a, s) + b_{jk}, & \text{if } a=a_{\rightarrow} \\
                  Q_{t}(a, s), & \text{otherwise}
                \end{array}
              \right.
$$
Finally, the RW updating equation that encodes instrumental learning is governed by the individual's learning rate for that condition, $\epsilon_{jk}$, and a scaling parameter $\rho_{jk}$ governing the effective size of the possible rewards $r_t \in \{0, 1, 5\}$:

$$
Q_{t}(a_t, s_t) = Q_{t-1}(a_t, s_t) + \epsilon_{jk}\big(\rho_{jk}r_t - Q_{t-1}(a_t, s_t)\big)
$$

## Hierarchical Parameters

Each parameter ($\epsilon, \rho, b, \xi$) varies by condition $k \in 1:K$, and by participant $j \in 1:J$ nested in sample $m \in 1:M$. 
The structure of the hierarchical part of the model is the same for each parameter, so the following description for $\epsilon$ will serve as a description for all of the parameters.
For each individual $j$, $\beta_{\epsilon j}$ is a $K$-element row of coefficients for parameter $\epsilon$ for each condition:

$$
\beta_{\epsilon j} \sim \mathcal{N}(\delta_{\epsilon mm[j]}, \Sigma_{\epsilon})
$$
where $\delta_{\epsilon mm[j]}$ is a column of $K$ means for individual $j$'s sample $M$, as indexed in the vector $mm$, and $\Sigma_{\epsilon}$ is a $K\times K$ matrix of the covariance of individual coefficients between conditions.

Finally, across all $M$ samples, the means for each condition k are distributed such that: 

$$
\delta_{\epsilon k} \sim \mathcal{N}(\mu_{\epsilon k}, \sigma_\epsilon)
$$

where $\mu_{\epsilon k}$ is the population mean for parameter $\epsilon$ in condition $k$, and $\sigma$ is a slightly regularizing scale parameter for these means across all conditions and samples. The priors for these final parameters are:

$$
\mu_\epsilon \sim \mathcal{N}(0, 5)\\
\sigma_\epsilon \sim \text{exponential(1)}.
$$

# Simulating data

Before modeling the task data, I will confirm that this model can recover known parameters from simulated data.
I simulate data based on the structure of the sample data, using the same number of participants per sample (see the section on [descriptive statistics](descriptive-statistics.html), as well as precisely the same task structure. 
For this aim, it is important to be able to recover all $\mu_{\theta k}$ for $\theta \in \{\epsilon,\rho,b,\xi\}$ and $k \in \{1,2,3\}$, where 1 = Hungry/Thirsty, 2 = Popular/Unpopular, and 3 = Dating/Looking. Those parameters that account for idiosyncratic deviation from RW-expected behavior ($b,\xi$) will not vary by condition. Based on interactive simulation ([here](https://jflournoy.shinyapps.io/rw_model/)), reasonable parameter values for the control condition might be $\mu_\epsilon = -1.65$ and $\mu_\rho = -0.3$ [^1].

The [`probly`](http://github.com/jflournoy/probly) package contains functions that help generate sample- and individually-varying coefficients for parameters, as well as simulated data from task structure.


```{r simulate_data_from_splt}
```

One early indication that a model may not be well suited to a particular data set is that the model, given reasonable parameter values, is not able to produce simulated data that looks like the real data one is attempting to model. The simulated data do generally behave similarly to the actual data when we look just at the proportion of optimal presses over time (Figure \@ref(fig:simdata) and Figure \@ref(fig:simdatasample), below, and Figure X in the section on [descriptive statistics](http://127.0.0.1:9740/rmd_output/4/descriptive-statistics.html)).

```{r}

p_r_df <- cbind(group_index_mm, splt_sim_trials$press_right)
p_r_df <- tidyr::gather(p_r_df, trial, press_r, -id, -sample, -m_fac, -m)

splt_sim <- dplyr::mutate(
    dplyr::arrange(
        dplyr::group_by(splt, id, sample),
        trial_index),
    trial = as.character(1:n()))
splt_sim <- dplyr::mutate(
    dplyr::arrange(
        dplyr::group_by(splt_sim, id, sample, condition),
        trial_index),
    condition_trial = 1:n())
splt_sim <- dplyr::left_join(
    splt_sim,
    p_r_df,
    by = c('id', 'sample', 'trial'))
splt_sim <- dplyr::mutate(
    splt_sim,
    press_r_opt = proportion == '20_80',
    press_opt = press_r == press_r_opt)

splt_sim_summary <- dplyr::summarise(
    dplyr::group_by(splt_sim, condition, condition_trial),
    trial_mean = mean(press_opt)
)
```



```{r simdata, fig.width=6, fig.height=5, fig.cap='(ref:simdat)'}

ggplot2::ggplot(
    splt_sim_summary,
    ggplot2::aes(x = condition_trial,
                 y = trial_mean,
                 group = condition,
                 linetype = condition,
                 shape = condition)) + 
    ggplot2::geom_point(alpha = .1) + 
    ggplot2::geom_smooth(
        color = 'black', size = .5,
        method = 'gam', formula = y ~ s(x, bs = "cs", k = 8), se = T) + 
    ggplot2::labs(x = 'Within-condition trial number',
                  y = 'Proportion of optimal responses') + 
    ggplot2::theme_minimal()
```

(ref:simdat) Simulated task data. This shows the the proportion of optimal presses across all participants for each trial. The best-fit line is a generalized additive model and is only intended for illustrative purposes.

```{r simdatasample, fig.width=6, fig.height=5, fig.cap='(ref:simdatsample)'}
splt_sim_samp_summary <- dplyr::summarise(
    dplyr::group_by(splt_sim, sample, condition, condition_trial),
    trial_mean = mean(press_opt)
)

ggplot2::ggplot(
    splt_sim_samp_summary,
    ggplot2::aes(x = condition_trial,
                 y = trial_mean,
                 group = condition,
                 linetype = condition,
                 shape = condition)) + 
    ggplot2::geom_point(alpha = .1) + 
    ggplot2::geom_smooth(
        color = 'black', size = .5,
        method = 'gam', formula = y ~ s(x, bs = "cs", k = 8), se = T) + 
    ggplot2::facet_wrap(~sample, nrow = 2) + 
    ggplot2::labs(x = 'Within-condition trial number',
                  y = 'Proportion of optimal responses') + 
    ggplot2::theme_minimal()
```

(ref:simdatsample) Simulated task data for each sample.

# Recovery of population parameters

```{r estimate_rl_from_sim, eval=T, message=F, results='hide'}
```

The model as described above was fit to simulated data using RStan [version `r packageVersion('rstan')`; @standevelopmentteam2018], sampling from 4 chains with 1000 warmup iterations and 500 sampling iterations per chain. 
The posterior means for each parameter are compared to those that generated the simulated task behavior.
The plots in Figure \@ref(fig:musimfitplot) allow visual comparison of the fitted model posteriors for each parameter to the data-generating population means, as well as to the means of the data-generating parameters for each sample, and for each individual.
It is clear from these plots that the parameter estimates from this particular run capture the generating parameters, with two exceptions. 
First, the estimate of the population mean of the irrudicble noise parameter, $\xi$, for one condition did not capture the generating parameter. 
This may be because this parameter was intentionally set very low so that $\xi^\prime \approx 0$. 
The second instance occurs with the bias parameter for one condition. 
This may be acceptable because the parameters of interest safely capture the generating values, and this single condition bias parameter is not very far from the identity line. 
Additionally, it should be noted that the fitted model does capture the mean of generating $\delta_b$ and $\beta_b$ parameters for all conditions.


```{r checking_fit_mu}
stan_sim_fit_data <- stan_sim_fit$data
stan_sim_fit_fit <- stan_sim_fit$fit

mu_param_ests <- probly::get_par_summaries(stan_sim_fit_fit, par_regex = '^mu_')

mu_param_ests_df <- as.data.frame(mu_param_ests)

mu_param_ests_df$population_val <- c(mu_xi, mu_eps, mu_b, mu_rho)
mu_param_ests_df$mean_of_deltas <- apply(cbind(delta_xi, delta_eps, delta_b, delta_rho), 2, mean)
mu_param_ests_df$mean_of_betas <- apply(cbind(beta_xi, beta_eps, beta_b, beta_rho), 2, mean)

mu_param_ests_df$id <- unlist(lapply(rownames(mu_param_ests_df), function(x) gsub('mu_delta_(\\w+)\\[\\d\\]', '\\1', x)))

mu_param_ests_df_l <- tidyr::gather(
    mu_param_ests_df,
    'pop_parameter',
    'value',
    population_val,
    mean_of_deltas,
    mean_of_betas)

mu_param_ests_df_l <- dplyr::mutate(
    mu_param_ests_df_l,
    pop_parameter = factor(
        pop_parameter,
        levels = c('population_val', 'mean_of_deltas', 'mean_of_betas'),
        labels = c(expression('Generating '*mu[delta]), 
                   expression("Mean of all "*delta),
                   expression("Mean of all "*beta))),
    id = factor(
        id,
        levels = c('ep', 'rho', 'b', 'xi'),
        labels = c('epsilon', 'rho', 'b', 'xi')
    )
)

mu_param_ests_df_l <- dplyr::mutate_at(
    mu_param_ests_df_l,
    dplyr::vars(value, mean, `2.5%`, `97.5%`),
    dplyr::funs(ifelse(id %in% c('epsilon','xi'), 
                pnorm(.),
                ifelse(id == 'rho', exp(.), .))))
```

```{r musimfitplot, fig.width=8, fig.height=8, fig.cap='(ref:musimfitplot)'}
ggplot2::ggplot(
   mu_param_ests_df_l,
   ggplot2::aes(y = mean, x = value)) + 
    ggplot2::geom_abline(intercept = 0, slope = 1) + 
    ggplot2::geom_errorbar(
        ggplot2::aes(ymin = `2.5%`, ymax = `97.5%`, width = 0), color = '#999999') + 
    ggplot2::geom_point(size = 2) + 
    ggplot2::theme_minimal() +
    ggplot2::facet_wrap(id ~ pop_parameter, ncol = 3, scales = 'free', labeller = 'label_parsed') +
    ggplot2::labs(x = 'Value of generating parameter',
                  y = expression('Mean of posterior distribution for '*mu[theta])) +
    ggplot2::theme(strip.text = element_text(size=10))
    
```

(ref:musimfitplot) Comparison of model fit to generating parameters. Gray bars are 95% credible intervals. Black lines are identinty, where model fit and generating parameters are exactly equal.

[^1]: Note that these are the _raw_ parameter values which are transformed such that $\epsilon^\prime \in [0,1]$ and $\rho^\prime \in [0,\infty)$.

# Conclusion

The model is able to recover data generating parameters from simulated data and is safe to use in interpretting the data provided by the study participants.

# References
